Placing Dungeon Objects and Creatures via Genetic Algorithm

The script generates object placements inside rooms generated by the BSP algorithm implementation in BSPDungeonGeneration.py .
Object placement in a dungeon can be formulated as a constraint satisfaction problem, where object type is constrained to specific rules of placement. For instance, windows and paintings should be on walls (edges).
The genetic algorithm (GA) randomly generates possible object placement combinations inside rooms. 
GA evaluates dungeon arrangements relative to the overall number of correct object placements (dungeon arrangements that have less object placement violations are considered more favorable solutions).
The GA will search for the best possible arrangement with optimally minimum placement erros.

Input Data Loading:

Reads RoomsAndObjects_clean.csv — each row describes a room type, its required objects (Has), placement rules (Corner, WallAdjacent, CenterAxis), and possible creatures.
JSON-like list columns are parsed into Python lists.
Each room row becomes a structured dictionary inside rooms_data.

BSP Room Geometry:
The genetic algorithm is applied to a set of rooms produced by the BSP (binary space partitioning) dungeon generator.
Each BSP room is represented by its 4 corner coordinates.

Individual Generation:
Each individual in the population represents a complete layout of object placements for all rooms.
The make_individual() function creates a random but constraint-respecting layout for every room.

Fitness Evaluation:
The fitness() function scores each layout based on:
Overlap penalty – objects can’t occupy the same coordinates.
Mutual exclusivity penalty – objects that can’t coexist (defined in CSV) reduce fitness.
Coverage reward – layouts that successfully place all expected objects and creatures score higher.

Genetic Algorithm Cycle:
The GA iterates over multiple generations:
Selection: Keeps the top-performing individuals (elitism).
Crossover: Mixes object placements between two parents to create new offspring.
Mutation: Randomly repositions some objects (respecting constraints).

After all generations, the best individual (highest fitness) is chosen.

Output:
The script returns or prints the best object layout.
Optionally visualized (in main.py) with Matplotlib to show room outlines and object locations.
